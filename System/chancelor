#!/bin/sh

# mytempo directory
MYTEMPO_DATA=

mytempo_upload() {

    $MYTEMPO_DATA/Online/setup.online ${1:-$MYTEMPO_DATA/database} upload
}

mytempo_update() {

    $MYTEMPO_DATA/Online/setup.online ${1:-$MYTEMPO_DATA/database} update
}

mytempo_save() {

    mkdir -p $1 && mv $MYTEMPO_DATA/database/N*.db $1
}

mytempo_save_backup_type() {

    mytempo_save "$MYTEMPO_DATA/database/$1/$(date +"%d.%m.%Y-%H_%M").$1"
}

mytempo_backup_all_prev_uploads() {

    mv $MYTEMPO_DATA/database/envio/* $MYTEMPO_DATA/database/backup
}

mytempo_upload_backup_type() {

    backup_dir=$MYTEMPO_DATA/database/$1

    for d in $backup_dir/*; do

	cp $MYTEMPO_DATA/database/equipamento.db $d

	# actual volume directory
	mytempo_upload $(realpath $d)
    done
}

mytempo_upload_backup() {

    # keep envio files for later
    mytempo_save_backup_type envio

    mytempo_update
    mytempo_upload_backup_type backup
}

mytempo_upload_normal() {

    mytempo_update
    mytempo_upload

    # send unsent files (if any)
    mytempo_upload_backup_type envio

    mytempo_save_backup_type backup
    mytempo_backup_all_prev_uploads
}

mytempo_dump_db() {
    
    # XXX: this goes through every db file in directory specified in first arg
    # ...  and then quotes every line and puts a ',' at the end then passes it
    # ...  to python and it parses this whole thing as a list and assigns it to 'a'
    # ...  then it zips every athlete number (which dont exceed 3 digits) with
    # ...  the corresponding time (everything else in the list which has more than 3
    # ...  digits). Then for every zipped tuple we print 24 - n of digits in athlete
    # ...  number and print the time of this athlete.
    python -c "a=[$((for i in $1/N*.db; do sqlite3 -line $i "select athlete_num, athlete_time from athletes_times"; done) | awk 'NF {print "\""$3"\""","}')];print(\"\\n\".join([f\"{\"0\"*(24-len(x))+x}{y}\" for x, y in zip(filter(lambda s: len(s) <= 3, a), filter(lambda s: len(s) > 3, a))]))"
}

mytempo_dump_all() {

    echo "This may take a while..."
    
    for d in $MYTEMPO_DATA/database/backup/*
    do
	mytempo_dump_db "$d" > /tmp/"dump_envio_$d"
    done

    for d in $MYTEMPO_DATA/database/envio/*
    do
	mytempo_dump_db "$d" > /tmp/"dump_envio_$d"
    done
    
    mytempo_dump_db $MYTEMPO_DATABASE/database > /tmp/dump
}

mytempo_usb_save() {

    mount /dev/sdb1 /mnt \
	&& mytempo_dump_all \
	&& mv /tmp/dump* /mnt \
	&& umount /mnt
}

mytempo_clean() {

    # XXX: this looks sus
    
    rm -rf $MYTEMPO_DATA/database/N*.db
    rm -rf $MYTEMPO_DATA/database/backup/*
    rm -rf $MYTEMPO_DATA/database/envio/*
}

echo "Chancelor, Version 1.1.0"

echo "Backing up leftover data (if any)"
test -e $MYTEMPO_DATA/database/N0.db \
    && mytempo_save_backup_type backup

while true;
do
    $MYTEMPO_DATA/Offline/setup.offline

    # wait for a signal
    read UPLOAD_TYPE < $MYTEMPO_DATA/database/sig-upload-data

    $MYTEMPO_DATA/Offline/stop.offline

    [ "$UPLOAD_TYPE" = "save"   ] && mytempo_usb_save
    [ "$UPLOAD_TYPE" = "reset"  ] && mytempo_clean
    [ "$UPLOAD_TYPE" = "reboot" ] && reboot
    [ "$UPLOAD_TYPE" = "normal" ] && mytempo_upload_normal
    [ "$UPLOAD_TYPE" = "backup" ] && mytempo_upload_backup

    sleep 5
done

